"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZksolcCompilerDownloader = void 0;
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const download_1 = require("hardhat/internal/util/download");
const utils_1 = require("../utils");
const constants_1 = require("../constants");
const errors_1 = require("./../errors");
/**
 * This class is responsible for downloading the zksolc binary.
 */
class ZksolcCompilerDownloader {
    /**
     * Use `getDownloaderWithVersionValidated` to create an instance of this class.
     */
    constructor(_version, _configCompilerPath, _compilersDirectory) {
        this._version = _version;
        this._configCompilerPath = _configCompilerPath;
        this._compilersDirectory = _compilersDirectory;
        this._isCompilerPathURL = (0, utils_1.isURL)(_configCompilerPath);
    }
    static async getDownloaderWithVersionValidated(version, configCompilerPath, compilersDir) {
        if (!ZksolcCompilerDownloader._instance) {
            let compilerVersionInfo = await ZksolcCompilerDownloader._getCompilerVersionInfo(compilersDir);
            if (compilerVersionInfo === undefined || (await ZksolcCompilerDownloader._shouldDownloadCompilerVersionInfo(compilersDir))) {
                try {
                    await ZksolcCompilerDownloader._downloadCompilerVersionInfo(compilersDir);
                }
                catch (e) {
                    throw new errors_1.ZkSyncSolcPluginError(constants_1.COMPILER_VERSION_INFO_FILE_DOWNLOAD_ERROR);
                }
                compilerVersionInfo = await ZksolcCompilerDownloader._getCompilerVersionInfo(compilersDir);
            }
            if (compilerVersionInfo === undefined) {
                throw new errors_1.ZkSyncSolcPluginError(constants_1.COMPILER_VERSION_INFO_FILE_NOT_FOUND_ERROR);
            }
            if (version === 'latest' || version === compilerVersionInfo.latest) {
                version = compilerVersionInfo.latest;
            }
            else if (!(0, utils_1.isVersionInRange)(version, compilerVersionInfo)) {
                throw new errors_1.ZkSyncSolcPluginError((0, constants_1.COMPILER_VERSION_RANGE_ERROR)(version, compilerVersionInfo.minVersion, compilerVersionInfo.latest));
            }
            else {
                console.info(chalk_1.default.yellow((0, constants_1.COMPILER_VERSION_WARNING)(version, compilerVersionInfo.latest)));
            }
            ;
            ZksolcCompilerDownloader._instance = new ZksolcCompilerDownloader(version, configCompilerPath, compilersDir);
        }
        return ZksolcCompilerDownloader._instance;
    }
    getVersion() {
        return this._version;
    }
    getCompilerPath() {
        let salt = '';
        if (this._isCompilerPathURL) {
            // hashed url used as a salt to avoid name collisions
            salt = (0, utils_1.saltFromUrl)(this._configCompilerPath);
        }
        else if (this._configCompilerPath) {
            return this._configCompilerPath;
        }
        return path_1.default.join(this._compilersDirectory, 'zksolc', `zksolc-v${this._version}${salt ? '-' : ''}${salt}`);
    }
    async isCompilerDownloaded() {
        if (this._configCompilerPath && !this._isCompilerPathURL) {
            await this._verifyCompiler();
            return true;
        }
        const compilerPath = this.getCompilerPath();
        return fs_extra_1.default.pathExists(compilerPath);
    }
    static async _shouldDownloadCompilerVersionInfo(compilersDir) {
        const compilerVersionInfoPath = this._getCompilerVersionInfoPath(compilersDir);
        if (!(await fs_extra_1.default.pathExists(compilerVersionInfoPath))) {
            return true;
        }
        const stats = await fs_extra_1.default.stat(compilerVersionInfoPath);
        const age = new Date().valueOf() - stats.ctimeMs;
        return age > ZksolcCompilerDownloader.compilerVersionInfoCachePeriodMs;
    }
    static _getCompilerVersionInfoPath(compilersDir) {
        return path_1.default.join(compilersDir, 'zksolc', 'compilerVersionInfo.json');
    }
    async downloadCompiler() {
        let compilerVersionInfo = await ZksolcCompilerDownloader._getCompilerVersionInfo(this._compilersDirectory);
        if (compilerVersionInfo === undefined || (await ZksolcCompilerDownloader._shouldDownloadCompilerVersionInfo(this._compilersDirectory))) {
            try {
                await ZksolcCompilerDownloader._downloadCompilerVersionInfo(this._compilersDirectory);
            }
            catch (e) {
                throw new errors_1.ZkSyncSolcPluginError(constants_1.COMPILER_VERSION_INFO_FILE_DOWNLOAD_ERROR);
            }
            compilerVersionInfo = await ZksolcCompilerDownloader._getCompilerVersionInfo(this._compilersDirectory);
        }
        if (compilerVersionInfo === undefined) {
            throw new errors_1.ZkSyncSolcPluginError(constants_1.COMPILER_VERSION_INFO_FILE_NOT_FOUND_ERROR);
        }
        if (!(0, utils_1.isVersionInRange)(this._version, compilerVersionInfo)) {
            throw new errors_1.ZkSyncSolcPluginError((0, constants_1.COMPILER_VERSION_RANGE_ERROR)(this._version, compilerVersionInfo.minVersion, compilerVersionInfo.latest));
        }
        try {
            console.info(chalk_1.default.yellow(`Downloading zksolc ${this._version}`));
            await this._downloadCompiler();
            console.info(chalk_1.default.green(`zksolc version ${this._version} successfully downloaded`));
        }
        catch (e) {
            throw new errors_1.ZkSyncSolcPluginError(e.message.split('\n')[0]);
        }
        await this._postProcessCompilerDownload();
        await this._verifyCompiler();
    }
    static async _downloadCompilerVersionInfo(compilersDir) {
        const url = `${constants_1.ZKSOLC_BIN_VERSION_INFO}/version.json`;
        const downloadPath = this._getCompilerVersionInfoPath(compilersDir);
        await (0, download_1.download)(url, downloadPath, 30000);
    }
    async _downloadCompiler() {
        let url = this._configCompilerPath;
        if (!this._isCompilerPathURL) {
            url = (0, utils_1.getZksolcUrl)(constants_1.ZKSOLC_BIN_REPOSITORY, this._version);
        }
        const downloadPath = this.getCompilerPath();
        await (0, download_1.download)(url, downloadPath, 30000);
        return downloadPath;
    }
    static async _readCompilerVersionInfo(compilerVersionInfoPath) {
        return fs_extra_1.default.readJSON(compilerVersionInfoPath);
    }
    static async _getCompilerVersionInfo(compilersDir) {
        const compilerVersionInfoPath = this._getCompilerVersionInfoPath(compilersDir);
        if (!(await fs_extra_1.default.pathExists(compilerVersionInfoPath))) {
            return undefined;
        }
        return await this._readCompilerVersionInfo(compilerVersionInfoPath);
    }
    async _postProcessCompilerDownload() {
        const compilerPath = this.getCompilerPath();
        fs_extra_1.default.chmodSync(compilerPath, 0o755);
    }
    async _verifyCompiler() {
        var _a, _b;
        const compilerPath = this.getCompilerPath();
        const versionOutput = (0, child_process_1.spawnSync)(compilerPath, ['--version']);
        const version = (_b = (_a = versionOutput.stdout) === null || _a === void 0 ? void 0 : _a.toString().match(/\d+\.\d+\.\d+/)) === null || _b === void 0 ? void 0 : _b.toString();
        if (versionOutput.status !== 0 || version == null) {
            throw new errors_1.ZkSyncSolcPluginError((0, constants_1.COMPILER_BINARY_CORRUPTION_ERROR)(compilerPath));
        }
    }
}
exports.ZksolcCompilerDownloader = ZksolcCompilerDownloader;
ZksolcCompilerDownloader.compilerVersionInfoCachePeriodMs = constants_1.DEFAULT_COMPILER_VERSION_INFO_CACHE_PERIOD;
//# sourceMappingURL=downloader.js.map